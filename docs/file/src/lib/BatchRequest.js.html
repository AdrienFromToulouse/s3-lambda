<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/lib/BatchRequest.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/littlstar/s3renity" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/lib/BatchRequest.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;

class BatchRequest {

  /**
   * @constructor
   * @param {Context} ctx The working context for the batch operation (contains
   * bucket, prefix, marker, encoding, etc.
   */

  constructor(ctx) {
    this.S3 = ctx.s3;
    this.bucket = ctx.bucket;
    this.prefix = ctx.prefix;
    this.marker = ctx._marker;
    this.encoding = ctx.encoding;
    this.transformer = ctx.transformer;
    this.delimiter = ctx.delimiter;
    this.target = ctx.target;
  }

  /**
   * Run a function over s3 objects in a for-each construct.
   *
   * @private
   * @param {Function} func The function to perform over the working context.
   * @param {Boolean} isAsync Optional, default is false. True if `func` is async (returns a
   * Promise).
   * @return {Promise}
   */

  forEach(func, isAsync) {

    if (typeof func != &apos;function&apos;) {
      throw new TypeError(&apos;first parameter `func` must be a Function.&apos;);
    }

    if (isAsync == null) {
      isAsync = false;
    }

    const _eachObject = (keys, callback) =&gt; {
      if (keys.length == 0) {
        callback(null);
        return;
      }
      const key = keys.shift();
      this.S3.get(this.bucket, key).then(body =&gt; {
        if (isAsync) {
          func(body).then(_ =&gt; {
            _eachObject(keys, callback);
          }).catch(callback);
        } else {
          try {
            func(body);
          } catch (e) {
            callback(e);
            return;
          }
          _eachObject(keys, callback);
        }
      }).catch(callback);
    };

    const _splitObjects = (keys, callback) =&gt; {
      if (keys.length == 0) {
        callback(null);
        return;
      }
      const key = keys.shift();
      this.S3.splitObject(this.bucket, key, this.delimiter, this.encoding)
        .then(entries =&gt; {
          _eachSplit(entries).then(_ =&gt; {
            _splitObjects(keys, callback);
          }).catch(callback);
        }).catch(callback);
    };

    const _eachSplit = entries =&gt; {
      return new Promise((success, fail) =&gt; {
        if (isAsync) {
          let updates = [];
          entries.forEach(entry =&gt; {
            updates.push(func(entry));
          });
          Promise.all(updates).then(success).catch(fail);
        } else {
          try {
            entries.forEach(func);
            success();
          } catch (err) {
            fail(err);
          }
        }
      });
    };

    return new Promise((success, fail) =&gt; {
      this.S3.list(this.bucket, this.prefix, this.marker).then(keys =&gt; {
        var lastKey = keys[keys.length - 1];
        if (this.delimiter == null) {
          _eachObject(keys, err =&gt; {
            if (err) {
              fail(err);
            } else {
              success(lastKey);
            }
          });
        } else {
          _splitObjects(keys, err =&gt; {
            if (err) {
              fail(err);
            } else {
              success(lastKey);
            }
          });
        }
      }).catch(fail);
    });
  }

  /**
   * Maps a function over the objects in the working context, replaceing each
   * with the return value.  If an output is specified, the objects will not be
   * overwritten, but rather copied to the target location.
   *
   * @public
   * @param {function} func The function to map over each object in the working
   * context. Func takes the object as a parameter and returns the value that
   * should replace it.
   * @param {boolean} isAsync Optional, default is false. If set to true, this
   * indicates that func returns a promise.
   * @return {promise} Fulfilled when map is complete.
   */

  map(func, isAsync) {

    if (typeof func != &apos;function&apos;) {
      throw new TypeError(INPUT_FUNCTION_ERROR);
    }

    if (isAsync == null) {
      isAsync = false;
    }

    const isSplit = this.delimiter != null;

    const _mapObject = (keys, callback) =&gt; {
      if (keys.length == 0) {
        callback(null);
        return;
      }
      let key = keys.shift();
      this.S3.get(this.bucket, key).then(body =&gt; {
        if (isAsync) {
          func(body)
            .then(newBody =&gt; _output(key, newBody, keys, callback))
            .catch(callback);
        } else {
          try {
            let newBody = func(body);
            _output(key, newBody, keys, callback);
          } catch (e) {
            callback(e);
            return;
          }
        }
      }).catch(callback);
    };

    const _splitObjects = (keys, callback) =&gt; {
      if (keys.length == 0) {
        callback(null);
        return;
      }
      let key = keys.shift();
      this.S3.splitObject(this.bucket, key, this.delimiter, this.encoding).then(
        entries =&gt; {
          _mapSplit(entries).then(newEntries =&gt; {
            let newBody = newEntries.join(this.delimiter);
            _output(key, newBody, keys, callback);
          }).catch(callback);
        }).catch(callback);
    };

    const _mapSplit = entries =&gt; {
      return new Promise((success, fail) =&gt; {
        if (isAsync) {
          let entryUpdates = [];
          entries.forEach(entry =&gt; {
            entryUpdates.push(func(entry));
          });
          Promise.all(entryUpdates).then(success).catch(fail);
        } else {
          try {
            success(entries.map(func));
          } catch (err) {
            fail(err);
          }
        }
      });
    };

    const _output = (key, body, keys, callback) =&gt; {
      if (this.target != null) {
        this
          .put(this.target.bucket, this.target.prefix + this.S3.getFileName(key), body)
          .then(_ =&gt; _continue(keys, callback))
          .catch(callback);
      } else {
        this.put(this.bucket, key, body)
          .then(_ =&gt; _continue(keys, callback))
          .catch(callback);
      }
    };

    const _continue = (keys, callback) =&gt; {
      if (isSplit) {
        _splitObjects(keys, callback);
      } else {
        _mapObject(keys, callback);
      }
    };

    return new Promise((success, fail) =&gt; {
      this.list().then(keys =&gt; {
        var lastKey = keys[keys.length - 1];
        if (isSplit) {
          _mapObject(keys, err =&gt; {
            if (err) {
              fail(err);
            } else {
              success(lastKey);
            }
          });
        } else {
          _splitObjects(keys, err =&gt; {
            if (err) {
              fail(err)
            } else {
              success(lastKey);
            }
          });
        }
      }).catch(fail);
    });
  }

  /**
   * Reduce the objects in the working context to a single value.
   *
   * @param {function} func Function to execute on each value in the array, taking
   * three arguments:
   *   previousValue - The value previously returned in the last invocation of
   *   func
   *   currentValue  - The current entry being processed
   *   key           - The key of the current object being processed
   *   func either returns the updated value, or a promise that resolves to the
   *   updated value.
   * @param {string} initialValue Optional.  Value to use as the first argument to
   * the first call of func.
   * @param {boolean} isAsync Optional, defaults to false. If set to true, this
   * indicates that func returns a promise.
   * @return {promise} Returns the reduced result.
   */

  reduce(func, initialValue, isAsync) {

    if (typeof func != &apos;function&apos;) {
      throw new TypeError(INPUT_FUNCTION_ERROR);
    }

    if (isAsync == null) {
      isAsync = false;
    }

    var value = initialValue;

    const _reduceObjects = (keys, callback) =&gt; {
      if (keys.length == 0) {
        callback(null, value);
        return;
      }
      let key = keys.shift();
      this.get(this.bucket, key).then(body =&gt; {
        if (isAsync) {
          func(value, body, key).then(newValue =&gt; {
            value = newValue;
            _reduceObjects(keys, callback);
          }).catch(e =&gt; callback(e, null));
        } else {
          value = func(value, body, key);
          _reduceObjects(keys, callback);
        }
      }).catch(e =&gt; callback(e, null));
    };

    const _splitAndReduceObjects = (keys, callback) =&gt; {
      if (keys.length == 0) {
        callback(null, value);
        return;
      }
      key = keys.shift();
      this.splitObject(this.bucket, key, this.delimiter, this.encoding).then(
        entries =&gt; {
          _reduceSplitEntries(key, entries, err =&gt; {
            if (err) {
              callback(err, null);
              return;
            }
            _splitAndReduceObjects(keys, callback);
          });
        }).catch(e =&gt; callback(e, null));
    };

    const _reduceSplitEntries = (key, entries, done) =&gt; {
      if (entries.length == 0) {
        done();
        return;
      }
      let entry = entries.shift();
      if (isAsync) {
        func(value, entry, key).then(newValue =&gt; {
          value = newValue;
          _reduceSplitEntries(key, entries, done);
        }).catch(done);
      } else {
        try {
          value = func(value, entry, key);
          _reduceSplitEntries(key, entries, done);
        } catch (e) {
          done(e);
        }
      }
    };

    return new Promise((success, fail) =&gt; {
      this.list().then(keys =&gt; {
        if (this.delimiter == null) {
          _reduceObjects(keys, (err, result) =&gt; {
            if (err) {
              fail(err);
            } else {
              success(result);
            }
          });
        } else {
          _splitAndReduceObjects(keys, (err, result) =&gt; {
            if (err) {
              fail(err);
            } else {
              success(result);
            }
          });
        }
      }).catch(fail);
    });
  }

  /**
   * Filter the objects in the working context.
   *
   * @public
   * @param {function} func The function to filter objects by, returning true for
   * objects that should not be filtered and false for those that should. If
   * isAsync is set to true, func returns a promise that resolves to true or
   * false.
   * @param {boolean} isAsync Optional, defaults to false. If set to true, this
   * indicates that func returns a promise.
   */

  filter(func, isAsync) {

    if (typeof func != &apos;function&apos;) {
      throw new TypeError(INPUT_FUNCTION_ERROR);
    }

    if (isAsync == null) {
      isAsync = false;
    }

    var removeObjects = [];
    var keepObjects = [];

    // recursively get all objects and run filter function
    const _filterObjects = (keys, callback) =&gt; {
      if (keys.length == 0) {
        _finish(callback);
        return;
      }
      let key = keys.shift();
      this.get(this.bucket, key).then(body =&gt; {
        if (isAsync) {
          func(body).then(result =&gt; {
            checkResult(result);
            if (result) {
              keepObjects.push(key);
            } else {
              removeObjects.push(key);
            }
            _filterObjects(keys, callback);
          }).catch(callback);
        } else {
          try {
            var result = func(body);
          } catch (e) {
            callback(e);
            return;
          }
          checkResult(result);
          if (result) {
            keepObjects.push(key);
          } else {
            removeObjects.push(key);
          }
          _filterObjects(keys, callback);
        }
      }).catch(callback);
    };

    const _finish = callback =&gt; {
      if (this.hasTarget) {
        let promises = [];
        keepObjects.forEach(key =&gt; {
          let fileName = this.S3.getFileName(key);
          promises.push(this.copy(this.bucket, key, this.targetBucket, this.targetPrefix + fileName));
        });
        Promise.all(promises).then(_ =&gt; {
          callback();
        }).catch(callback);
      } else {
        this.delete(this.bucket, removeObjects).then(_ =&gt; {
          callback(null);
        }).catch(callback);
      }
    };

    const _splitObjects = (keys, callback) =&gt; {
      if (keys.length == 0) {
        callback(null);
        return;
      }
      let key = keys.shift();
      this.splitObject(this.bucket, key, this.delimiter, this.encoding)
        .then(entries =&gt; {
          _filterSplitObject(entries).then(newEntries =&gt; {
            var targetBucket, targetKey;
            let newBody = newEntries.join(this.delimiter);
            if (this.hasTarget) {
              targetBucket = this.targetBucket;
              targetKey = this.targetPrefix + this.S3.getFileName(key);
            } else {
              targetBucket = this.bucket;
              targetKey = key;
            }
            this.put(targetBucket, targetKey, newBody).then(_ =&gt; {
              _splitObjects(keys, callback);
            }).catch(callback);
          }).catch(callback);
        }).catch(callback);
    };

    // runs the filter function on a split (containing entries)
    const _filterSplitObject = entries =&gt; new Promise((success, fail) =&gt; {
      if (isAsync) {
        promises = [];
        entries.forEach(entry =&gt; {
          promises.push(func(entry));
        });
        Promise.all(promises).then(results =&gt; {
          let newSplitEntries = [];
          results.forEach((pass, i) =&gt; {
            if (pass) {
              newSplitEntries.push(entries[i]);
            }
            success(newSplitEntries);
          });
        }).catch(fail);
      } else {
        try {
          success(entries.filter(func));
        } catch (err) {
          fail(err);
        }
      }
    });

    const checkResult = result =&gt; {
      if (typeof result != &apos;boolean&apos;) {
        throw new TypeError(&apos;Filter function must return a boolean&apos;);
      }
    };

    return new Promise((success, fail) =&gt; {
      this.list().then(keys =&gt; {
        if (this.delimiter == null) {
          _filterObjects(keys, err =&gt; {
            if (err) {
              fail(err);
            } else {
              success();
            }
          });
        } else {
          _splitObjects(keys, err =&gt; {
            if (err) {
              fail(err);
            } else {
              success();
            }
          });
        }
      }).catch(fail);
    });
  }

  /**
   * Join the objects in the working context by the given delimiter and return the
   * result.
   *
   * @public
   * @param {string} delimiter The character used to join the documents by.
   * Default is &quot;\n&quot;
   * @return {promise} Returns the body and `this` on success.
   */

  join(delimiter) {
    if (delimiter == null) delimiter = &apos;\n&apos;;
    return new Promise((success, fail) =&gt; {
      this.list().then(keys =&gt; {
        let getPromises = [];
        keys.forEach(key =&gt; {
          getPromises.push(this.get(this.bucket, key));
        });
        Promise.all(getPromises).then(objects =&gt; {
          success(objects.join(delimiter));
        }).catch(fail);
      }).catch(fail);
    });
  }

}

module.exports = BatchRequest;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
