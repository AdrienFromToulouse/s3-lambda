<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/lib/Context.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/littlstar/s3renity" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/lib/Context.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;

class Context {

  /**
   * @constructor
   * @param {String} key A valid S3 key, which is used to generate the context
   * for the batch operations.
   * @param {String} marker Optional. The marker to start at when getting objects from `key`.
   * @param {S3} S3 The s3 instance to use in batch requests.
   */

  constructor(key, marker, S3) {
    let context = S3.resolveKey(key);
    if (context.type != &apos;s3&apos;) {
      throw new Error(&apos;context must be valid s3 path&apos;);
    }
    this.bucket = context.bucket;
    this.prefix = context.prefix;
    this.marker = marker;
    this.S3 = S3;
  }

  /**
   * Set the marker for the working context (file to start on)
   * @param {String} marker The marker to start with for getting objects.
   * @return {Context} `this`
   */

  marker(marker) {
    this.marker = marker;
    return this;
  }

  /**
   * @param {String} encoding
   * @returns {Context} `this`
   */

  encode(encoding) {
    this.encoding = encoding;
    return this;
  }

  /**
   * Transforms the S3 object before proceeding.
   *
   * @param {Function} transform The function to use to transform the object.
   * @return {Context} `this`
   */

  transform(transformer) {
    this.transformer = transformer;
    return this;
  }

  /**
   * Move the context from s3 objects to objects split by a delimiter.
   *
   * @param {string} delimiter The character to split the document objects by.
   * Default is &quot;\n&quot;
   * @return {Context} `this`
   */

  split(delimiter) {
    this.delimiter = delimiter || &apos;\n&apos;;
    return this;
  }

  /**
   * Sets the output directory for map or filter.  If a target is set, map and
   * filter write to that location instead of changing the original objects
   * themselves.
   *
   * @param {String} target The location to send the output of map or filter.
   * @return {Context} `this`
   */

  target(target) {
    this.target = S3.resolveKey(target);
    return this;
  }

  /**
   * Returns a for each batch request.
   *
   * @param {Function} func This function takes an s3 object and performs a
   * synchronous function. If isAsync is true, func returns a promise.
   * @param {Boolean} isAsync Optional. Default is false. If set to true, this
   * indicates that func returns a promise that should be executed.
   * @returns {Promise} Fulfilled when the mapper functions are done. Returns a
   * list of keys that were operated over.
   */

  forEach(func, isAsync) {
    let batch = new BatchRequest(this);
    return batch.forEach(func, isAsync);
  }

  /**
   * @param {Function} func This function takes an s3 object and returns the updated object.
   * @param {Boolean} isAsync Whether the function is asynchronous (returns a
   * promise).
   * @return {Promise}
   */

  map(func, isAsync) {
    let batch = new BatchRequest(this);
    return batch.map(func, isAsync);
  }

  /**
   * @param {Function} func The reducer function.
   * @param {Mixed} initialValue The value to start with in `func`.
   * @param {Boolean} isAsync Whether the function is asynchronous (returns a promise).
   */

  reduce(func, initialValue, isAsync) {
    let batch = new BatchRequest(this);
    return batch.reduce(func, initialValue, isAsync);
  }

  filter(func, isAsync) {
    let batch = new BatchRequest(this);
    return batch.filter(func, isAsync);
  }

  join(delimiter) {
    let batch = new BatchRequest(this);
    return batch.join(delimiter);
  }

}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
